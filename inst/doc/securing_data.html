<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Administrative file to be wrangled</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>This vignette walks through the process for using duawranglr. It
assumes that the data administrator and researcher have executed a
data usage agreement (DUA) with three potential levels of data
restrictions and created a crosswalk spreadsheet in Excel.</p>

<h2>Administrative file to be wrangled</h2>

<p>The raw administrative data file that needs to be processed looks like
this:  </p>

<table><thead>
<tr>
<th align="center">sid</th>
<th align="center">sname</th>
<th align="center">dob</th>
<th align="center">gender</th>
<th align="center">raceeth</th>
<th align="center">tid</th>
<th align="center">tname</th>
<th align="center">zip</th>
<th align="center">mathscr</th>
<th align="center">readscr</th>
</tr>
</thead><tbody>
<tr>
<td align="center">000-00-0001</td>
<td align="center">Schaefer</td>
<td align="center">19900114</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">Smith</td>
<td align="center">22906</td>
<td align="center">515</td>
<td align="center">496</td>
</tr>
<tr>
<td align="center">000-00-0002</td>
<td align="center">Hodges</td>
<td align="center">19900225</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">Smith</td>
<td align="center">22906</td>
<td align="center">488</td>
<td align="center">489</td>
</tr>
<tr>
<td align="center">000-00-0003</td>
<td align="center">Kirby</td>
<td align="center">19900305</td>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">Smith</td>
<td align="center">22906</td>
<td align="center">522</td>
<td align="center">498</td>
</tr>
<tr>
<td align="center">000-00-0004</td>
<td align="center">Estrada</td>
<td align="center">19900419</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">Smith</td>
<td align="center">22906</td>
<td align="center">516</td>
<td align="center">524</td>
</tr>
<tr>
<td align="center">000-00-0005</td>
<td align="center">Nielsen</td>
<td align="center">19900530</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">Smith</td>
<td align="center">22906</td>
<td align="center">483</td>
<td align="center">509</td>
</tr>
<tr>
<td align="center">000-00-0006</td>
<td align="center">Dean</td>
<td align="center">19900621</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">Brown</td>
<td align="center">22906</td>
<td align="center">503</td>
<td align="center">523</td>
</tr>
<tr>
<td align="center">000-00-0007</td>
<td align="center">Hickman</td>
<td align="center">19900712</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">Brown</td>
<td align="center">22906</td>
<td align="center">539</td>
<td align="center">509</td>
</tr>
<tr>
<td align="center">000-00-0008</td>
<td align="center">Bryant</td>
<td align="center">19900826</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">Brown</td>
<td align="center">22906</td>
<td align="center">499</td>
<td align="center">490</td>
</tr>
<tr>
<td align="center">000-00-0009</td>
<td align="center">Lynch</td>
<td align="center">19900902</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">Brown</td>
<td align="center">22906</td>
<td align="center">499</td>
<td align="center">493</td>
</tr>
</tbody></table>

<p>And we have a codebook:  </p>

<ul>
<li><code>sid</code>: Student social security number<br/></li>
<li><code>sname</code>: Student&#39;s last name<br/></li>
<li><code>dob</code>: Student&#39;s date of birth<br/></li>
<li><code>gender</code>: Indicator for student gender identification<br/></li>
<li><code>raceeth</code>: Factor variable indicatings student&#39;s racial/ethnic
identification<br/></li>
<li><code>tid</code>: ID variable for student&#39;s teacher<br/></li>
<li><code>tname</code>: Last name of student&#39;s teacher<br/></li>
<li><code>zip</code>: Student&#39;s home address zip code<br/></li>
<li><code>mathscr</code>: Student&#39;s end-of-year test math score<br/></li>
<li><code>readscr</code>: Student&#39;s end-of-year test reading score<br/></li>
</ul>

<p>The <code>admin_data.csv</code> file contains observations for 9 students and has 10
variables associated with each observation. Of these, 1 uniquely
identifies each student, 6 are associated with the student&#39;s personal
characteristics, 2 with each student&#39;s teacher, and 2 with the
student&#39;s test scores in reading and math. </p>

<p>It appears that the school uses the student&#39;s social security number
to uniquely identify each student. As researchers interested in test
scores, we have no need for this highly protected data element other
than for its ability to uniquely identify a student or allow linking
to other records. Since we do not need to link to other records at the
moment, any unique number or string will work for our
purposes. Similarly, we don&#39;t really need the student&#39;s last name.</p>

<p>Besides math (<code>mathscr</code>) and reading (<code>readscr</code>) scores, we may be
interested in some of the other covariates. It&#39;s likely that many of
these data elements, however, also carry restrictions of varying
severity. For example, the school may be able to share the student&#39;s
race/ethnicity and gender (provided the student is not otherwise
identified) with most approved researchers, but can only share
teachers&#39; names (<code>tid</code>) under more tightly restricted scenarios.</p>

<p>This is where our DUA crosswalk file comes in handy.</p>

<h2>Set DUA</h2>

<p>The first step in the process is to set the DUA crosswalk file. The
crosswalk file can be in many different formats and, in most cases,
will be read in automatically no matter the type. (If using a
delimited file that isn&#39;t a comma- or tab-separated value format, give
the <code>delimiter</code> argument the delimiter string; if using an Excel file
with more than one sheet, give the <code>sheet</code> argument the sheet name or
number.) If successful, you will get message telling you so.</p>

<pre><code class="r">library(tidyverse)
library(duawranglr)

## get crosswalk and admin data files
dua_cw_file &lt;- system.file(&#39;extdata&#39;, &#39;dua_cw.csv&#39;, package = &#39;duawranglr&#39;)
admin_file &lt;- system.file(&#39;extdata&#39;, &#39;admin_data.csv&#39;, package = &#39;duawranglr&#39;)

## set the DUA crosswalk
set_dua_cw(dua_cw_file)
</code></pre>

<pre><code>-- duawranglr note -----------------------------------------------------------------------
DUA crosswalk has been set!
</code></pre>

<h2>Check DUA options</h2>

<p>In case you&#39;ve forgotten the data elements that are restricted at a
particular level, you can check them using the <code>see_dua_options()</code>
function with the <code>level</code> argument set to the appropriate level. If you
want to compare restrictions across more than one level, you can give
the <code>level</code> argument a vector.</p>

<pre><code class="r">## compare level II and III restrictions
see_dua_options(level = c(&#39;level_ii&#39;, &#39;level_iii&#39;))
------------------------------------------------------------------------------------------
LEVEL NAME: level_ii
------------------------------------------------------------------------------------------

RESTRICTED VARIABLE NAMES:
 - dob
 - sid
 - sname
 - tname
 - zip

------------------------------------------------------------------------------------------
LEVEL NAME: level_iii
------------------------------------------------------------------------------------------

RESTRICTED VARIABLE NAMES:
 - sid
 - sname
 - tname

------------------------------------------------------------------------------------------
</code></pre>

<p>Alternately, you can see restrictions at all levels if you leave the
<code>level</code> argument at its default <code>NULL</code> value.</p>

<pre><code class="r">## check all level restrictions
see_dua_options()
------------------------------------------------------------------------------------------
LEVEL NAME: level_i
------------------------------------------------------------------------------------------

RESTRICTED VARIABLE NAMES:
 - dob
 - gender
 - raceeth
 - sid
 - sname
 - tid
 - tname
 - zip

------------------------------------------------------------------------------------------
LEVEL NAME: level_ii
------------------------------------------------------------------------------------------

RESTRICTED VARIABLE NAMES:
 - dob
 - sid
 - sname
 - tname
 - zip

------------------------------------------------------------------------------------------
LEVEL NAME: level_iii
------------------------------------------------------------------------------------------

RESTRICTED VARIABLE NAMES:
 - sid
 - sname
 - tname

------------------------------------------------------------------------------------------
</code></pre>

<h2>Set DUA level</h2>

<p>After consultation with our data partner, we&#39;ve decided that data for
this project need to be set at Level II. Because no level allows us to
use the current unique ID, <code>sid</code>, we also need to deidentify the
data. We could just delete the <code>sid</code> column, but for reasons discussed
below, it will be better if we use it to make new, non-identifiable
but unique IDs. Therefore, we use additional arguments in
<code>set_dua_level()</code> to note that deidentification is required and set the
targeted ID column.</p>

<pre><code class="r">## set DUA level
set_dua_level(&#39;level_ii&#39;, deidentify_required = TRUE, id_column = &#39;sid&#39;)
-- duawranglr note -----------------------------------------------------------------------
Unique IDs in [ sid ] must be deidentified; use -deid_dua()-.
</code></pre>

<h2>Check DUA level</h2>

<p>As we&#39;re preparing the data, we can check our restriction level and
the data element names it restricts using <code>see_dua_level()</code>. </p>

<pre><code class="r">## see set DUA level 
see_dua_level(show_restrictions = TRUE)
------------------------------------------------------------------------------------------
You have set restrictions at [ level_ii ]
------------------------------------------------------------------------------------------

RESTRICTED VARIABLE NAMES:
 - dob
 - sid
 - sname
 - tname
 - zip

------------------------------------------------------------------------------------------
</code></pre>

<h1>Administrative data</h1>

<p>After loading some libraries, we&#39;ll first read in the raw
administrative data file and confirm that it has nine observations and
the data elements we expect.</p>

<pre><code class="r">## read in raw administrative data
df &lt;- read_dua_file(admin_file)
df
</code></pre>

<pre><code># A tibble: 9 x 10
  sid         sname    dob      gender raceeth   tid tname   zip mathscr readscr
  &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;     &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt;   &lt;int&gt;   &lt;int&gt;
1 000-00-0001 Schaefer 19900114      0       2     1 Smith 22906     515     496
2 000-00-0002 Hodges   19900225      0       1     1 Smith 22906     488     489
3 000-00-0003 Kirby    19900305      0       4     1 Smith 22906     522     498
4 000-00-0004 Estrada  19900419      0       3     1 Smith 22906     516     524
5 000-00-0005 Nielsen  19900530      1       2     1 Smith 22906     483     509
6 000-00-0006 Dean     19900621      1       1     2 Brown 22906     503     523
7 000-00-0007 Hickman  19900712      1       1     2 Brown 22906     539     509
8 000-00-0008 Bryant   19900826      0       2     2 Brown 22906     499     490
9 000-00-0009 Lynch    19900902      1       3     2 Brown 22906     499     493
</code></pre>

<h1>Deidentify data</h1>

<h2>Single file or no existing crosswalk</h2>

<p>We indicated that the data need to be deidentified, so a good first
step in cleaning the raw data is to convert unique student id, <code>sid</code>,
into a similarly unique, but unidentifiable value. </p>

<p>Why not just generate some random string for each value? Though we
don&#39;t care to merge these data with other files, we may need to do so
in the future. If we randomly generate new IDs, discarding the old
ones in the process, we will be stuck.</p>

<p>The <code>deid_dua()</code> function does two things:</p>

<ol>
<li>It uses a secure <code>SHA-2</code> algorithm to convert sensitive IDs into
unique hexadecimal strings that cannot be reverted back to the
originial IDs (important in the case such as ours when the unique
ID is the student&#39;s social security number);</li>
<li>It has the option to save a crosswalk file that links the old
secure IDs to the new IDs.</li>
</ol>

<p>Clearly, it defeats the purpose of deidentifying IDs if a crosswalk
between old and new travels with the new data. But if the crosswalk
file is keep in a secure location, perhaps on the same server that
hosts the raw administrative data, then old IDs can be retrieved if
necessary by those with the proper clearance to do so.</p>

<pre><code class="r">## deidentify data
df &lt;- deid_dua(df, write_crosswalk = TRUE, id_length = 20)
</code></pre>

<p>Here&#39;s what the saved crosswalk looks like:</p>

<pre><code># A tibble: 9 x 2
  sid         id                  
  &lt;chr&gt;       &lt;chr&gt;               
1 000-00-0001 68ea6f07fddc8a1e525c
2 000-00-0002 d98ea32abc9d6f079bd7
3 000-00-0003 f23714e567008389d031
4 000-00-0004 c97720c2bb7514069648
5 000-00-0005 7eebe59e0dd688b17f36
6 000-00-0006 b1562c001d69e706f026
7 000-00-0007 0d11deed8ea05a340321
8 000-00-0008 cb4ec10ddc53aa78adce
9 000-00-0009 1192b853d2b8fda3ee66
</code></pre>

<p>And here now is the data frame:</p>

<pre><code class="r">## show data frame
df
# A tibble: 9 x 10
  id                   sname    dob      gender raceeth   tid tname   zip mathscr readscr
  &lt;chr&gt;                &lt;chr&gt;    &lt;chr&gt;     &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt;   &lt;int&gt;   &lt;int&gt;
1 68ea6f07fddc8a1e525c Schaefer 19900114      0       2     1 Smith 22906     515     496
2 d98ea32abc9d6f079bd7 Hodges   19900225      0       1     1 Smith 22906     488     489
3 f23714e567008389d031 Kirby    19900305      0       4     1 Smith 22906     522     498
4 c97720c2bb7514069648 Estrada  19900419      0       3     1 Smith 22906     516     524
5 7eebe59e0dd688b17f36 Nielsen  19900530      1       2     1 Smith 22906     483     509
6 b1562c001d69e706f026 Dean     19900621      1       1     2 Brown 22906     503     523
7 0d11deed8ea05a340321 Hickman  19900712      1       1     2 Brown 22906     539     509
8 cb4ec10ddc53aa78adce Bryant   19900826      0       2     2 Brown 22906     499     490
9 1192b853d2b8fda3ee66 Lynch    19900902      1       3     2 Brown 22906     499     493
</code></pre>

<h2>Links across multiple files with existing crosswalk</h2>

<p>If the deidentified data frame is built from multiple files (<em>e.g.</em>, a
panel data set of observations across years), then we&#39;ll want to reuse
an existing crosswalk. Otherwise, the same original ID will end up
with multiple new IDs and we won&#39;t be able to link observations across
data sets.</p>

<p>Let&#39;s say we already have master crosswalk file that looks like this:</p>

<pre><code># A tibble: 9 x 2
  sid         id                  
  &lt;chr&gt;       &lt;chr&gt;               
1 000-00-0001 db3681caa7e4789c9a99
2 000-00-0002 8e13af4fbb998c26348f
3 000-00-0003 2c7f2f98f9ee0e3b69ba
4 000-00-0004 ed7041ab2076a84fe611
5 000-00-0005 d4180e00af840a7a8e29
6 000-00-0006 9d42b365e2e49989b620
7 000-00-0007 a997bd9ffc4ee8030081
8 000-00-0008 43fc27899df21721b0c5
9 000-00-0009 e3150a7010e9a08d52f0
</code></pre>

<p>Rather than create new IDs, we can use the <code>existing_crosswalk</code>
argument to read in and use the new IDs we&#39;ve already made. Everything
else works the same as before.    </p>

<pre><code class="r">df &lt;- deid_dua(df, existing_crosswalk = &#39;master_crosswalk.csv&#39;)
</code></pre>

<p>The new ID values now match those from the crosswalk.</p>

<pre><code class="r">df
# A tibble: 9 x 10
  id                   sname    dob      gender raceeth   tid tname   zip mathscr readscr
  &lt;chr&gt;                &lt;chr&gt;    &lt;chr&gt;     &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt;   &lt;int&gt;   &lt;int&gt;
1 db3681caa7e4789c9a99 Schaefer 19900114      0       2     1 Smith 22906     515     496
2 8e13af4fbb998c26348f Hodges   19900225      0       1     1 Smith 22906     488     489
3 2c7f2f98f9ee0e3b69ba Kirby    19900305      0       4     1 Smith 22906     522     498
4 ed7041ab2076a84fe611 Estrada  19900419      0       3     1 Smith 22906     516     524
5 d4180e00af840a7a8e29 Nielsen  19900530      1       2     1 Smith 22906     483     509
6 9d42b365e2e49989b620 Dean     19900621      1       1     2 Brown 22906     503     523
7 a997bd9ffc4ee8030081 Hickman  19900712      1       1     2 Brown 22906     539     509
8 43fc27899df21721b0c5 Bryant   19900826      0       2     2 Brown 22906     499     490
9 e3150a7010e9a08d52f0 Lynch    19900902      1       3     2 Brown 22906     499     493
</code></pre>

<h2>Updates to existing crosswalk</h2>

<p>In our example, we have nine students in the current file. Let&#39;s say
that though we have a crosswalk, it only has new IDs for the first
five observations:</p>

<pre><code># A tibble: 5 x 2
  sid         id                  
  &lt;chr&gt;       &lt;chr&gt;               
1 000-00-0001 db3681caa7e4789c9a99
2 000-00-0002 8e13af4fbb998c26348f
3 000-00-0003 2c7f2f98f9ee0e3b69ba
4 000-00-0004 ed7041ab2076a84fe611
5 000-00-0005 d4180e00af840a7a8e29
</code></pre>

<p>If the existing crosswalk doesn&#39;t have values for all observations,
then <code>deid_dua()</code> will:  </p>

<ol>
<li>Match old IDs with new IDs that <strong>do</strong> exist in the crosswalk</li>
<li>Generate new IDs for the old IDs that <strong>don&#39;t</strong> exist in the
crosswalk</li>
<li>Update and save the crosswalk</li>
</ol>

<p>The command is the same for a partial crosswalk as for a complete crosswalk.</p>

<pre><code class="r">df &lt;- deid_dua(df, existing_crosswalk = &#39;crosswalk_partial.csv&#39;)
</code></pre>

<p>Notice that the new IDs for the first five observations match those
that were already in the existing crosswalk. The last four are new.</p>

<pre><code class="r">df
# A tibble: 9 x 10
  id                   sname    dob      gender raceeth   tid tname   zip mathscr readscr
  &lt;chr&gt;                &lt;chr&gt;    &lt;chr&gt;     &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt;   &lt;int&gt;   &lt;int&gt;
1 db3681caa7e4789c9a99 Schaefer 19900114      0       2     1 Smith 22906     515     496
2 8e13af4fbb998c26348f Hodges   19900225      0       1     1 Smith 22906     488     489
3 2c7f2f98f9ee0e3b69ba Kirby    19900305      0       4     1 Smith 22906     522     498
4 ed7041ab2076a84fe611 Estrada  19900419      0       3     1 Smith 22906     516     524
5 d4180e00af840a7a8e29 Nielsen  19900530      1       2     1 Smith 22906     483     509
6 9c0975c2a6da6f07abcc Dean     19900621      1       1     2 Brown 22906     503     523
7 be19195522c69f6dd3e1 Hickman  19900712      1       1     2 Brown 22906     539     509
8 1c457e1ab5cd98367cbc Bryant   19900826      0       2     2 Brown 22906     499     490
9 e6d201fb1a9ae0ac9968 Lynch    19900902      1       3     2 Brown 22906     499     493
</code></pre>

<p>Looking at the partial crosswalk, we see that it now has four new rows
with new IDs each for the observations it didn&#39;t have before. </p>

<pre><code># A tibble: 9 x 2
  sid         id                  
  &lt;chr&gt;       &lt;chr&gt;               
1 000-00-0001 db3681caa7e4789c9a99
2 000-00-0002 8e13af4fbb998c26348f
3 000-00-0003 2c7f2f98f9ee0e3b69ba
4 000-00-0004 ed7041ab2076a84fe611
5 000-00-0005 d4180e00af840a7a8e29
6 000-00-0006 9c0975c2a6da6f07abcc
7 000-00-0007 be19195522c69f6dd3e1
8 000-00-0008 1c457e1ab5cd98367cbc
9 000-00-0009 e6d201fb1a9ae0ac9968
</code></pre>

<p>Should we encounter those students in future files, <code>deid_dua()</code> will
use the new IDs we just created.</p>

<h1>Check data frame</h1>

<p>If we try to write the data frame using the <code>write_dua_df()</code> function,
we get an error.</p>

<pre><code class="r">## write data to disk with one last check
write_dua_df(df, &#39;cleaned_data.csv&#39;, output_type = &#39;csv&#39;)
-- duawranglr note -----------------------------------------------------------------------
Data set has not yet passed check. Run -check_dua_restrictions()- to check status.
</code></pre>

<p>Right, we haven&#39;t removed all the restricted data elements. Following
the directions, we can check to see what still needs to be removed
using the <code>check_dua_restrictions()</code> function.</p>

<pre><code class="r">## check
check_dua_restrictions(df)
-- duawranglr note -----------------------------------------------------------------------
The following variables are not allowed at the current data usage level restriction [
level_ii ] and MUST BE REMOVED before saving:
 - sname
 - dob
 - tname
 - zip
</code></pre>

<p>We&#39;ve successfully removed <code>sid</code> already (when we deidentified the
data frame), but still have to remove the student&#39;s last name, date of
birth, teacher&#39;s name, and zip code to meet level II
restrictions. Once we remove those columns, we can check again.</p>

<pre><code class="r">## remove restricted columns
df &lt;- df %&gt;% select(-c(sname, dob, tname, zip))

## check again
check_dua_restrictions(df)
-- duawranglr note -----------------------------------------------------------------------
Data set has passed check and may be saved.
</code></pre>

<p>Success! And to be sure, here&#39;s what our data frame looks like now:</p>

<pre><code class="r">df
# A tibble: 9 x 6
  id                   gender raceeth   tid mathscr readscr
  &lt;chr&gt;                 &lt;int&gt;   &lt;int&gt; &lt;int&gt;   &lt;int&gt;   &lt;int&gt;
1 db3681caa7e4789c9a99      0       2     1     515     496
2 8e13af4fbb998c26348f      0       1     1     488     489
3 2c7f2f98f9ee0e3b69ba      0       4     1     522     498
4 ed7041ab2076a84fe611      0       3     1     516     524
5 d4180e00af840a7a8e29      1       2     1     483     509
6 9c0975c2a6da6f07abcc      1       1     2     503     523
7 be19195522c69f6dd3e1      1       1     2     539     509
8 1c457e1ab5cd98367cbc      0       2     2     499     490
9 e6d201fb1a9ae0ac9968      1       3     2     499     493
</code></pre>

<h1>Write cleaned data frame to disk</h1>

<p>Now that we&#39;ve passed our check, we can write the level II secure data
frame to disk. Just like the <code>set_dua_cw()</code> function, which automates
reading in many types of files, <code>write_dua_df()</code> will write many types
of files. See <code>?write_dua_df</code> for options.</p>

<pre><code class="r">## write data to disk 
write_dua_df(df, &#39;cleaned_data_lev_ii.csv&#39;, output_type = &#39;csv&#39;)
</code></pre>

<h1>Interactive template</h1>

<p>Particularly for the first few times you use this package, you may
need help remembering the steps. To help the process, the interactive
<code>make_dua_template()</code> function will help you make a template script
that you can then modify to meet your data cleaning needs. When
called, the function will ask you a few yes or no questions and, based
on your answers, build a template script that pre-fills some function
arguments. </p>

<p>An example template script is printed below.</p>

<pre><code class="r">## save template to disk
make_dua_template(&#39;clean_data.R&#39;)
</code></pre>

<h4>EXAMPLE</h4>

<pre><code>################################################################################
##
## [ Proj ] &lt; general project name &gt;
## [ File ] clean_data.R
## [ Auth ] &lt; author name &gt;
## [ Init ] 19 November 2019
##
################################################################################

## ---------------------------
## libraries
## ---------------------------

## NOTES: Include additional libraries using either -library()- or -require()-
## functions here.

## ---------------------------
## set DUA crosswalk
## ---------------------------

## NOTES: Choose the DUA agreement crosswalk file if you didn&#39;t when setting up
## the template. If the file is a delimited file that isn&#39;t a CSV or TSV, be
## sure to indicate the delimiter string with the -delimiter- argument.
## Similarly if the crosswalk is in an Excel file on any sheet beyond the
## first, set the -sheet- argument to the correct sheet.

set_dua(dua = &#39;&lt; dua crosswalk file name &gt;&#39;)

## ---------------------------
## set DUA level
## ---------------------------

## NOTES: Choose the DUA agreement crosswalk level. If you indicated that the
## data should be deidentified, those options, including the ID column if
## choosen, are included below. If you did not indicate the name of the ID
## column to be deidentified, add its name after the -id_column- argument.
## 
## If you did not indicate that the data should be deidentified, but they
## should be, see ?deid_dua().

set_dua_level(level = &#39;&lt; level name &gt;&#39;)

## ---------------------------
## data cleaning
## ---------------------------

## NOTES: Use standard scripts to build and clean data set here.

## ---------------------------
## check DUA restrictions
## ---------------------------

## NOTES: If your data frame includes restricted data elements or should have
## been deidentified and has not been, -check_dua_restrictions()- will return
## an error and stop. Fix above and rerun or set -remove_protected- arguement
## to TRUE to automatically remove restricted columns.

check_dua_restrictions(df = &#39;&lt; data frame &gt;&#39;)

## ---------------------------
## write cleaned file
## ---------------------------

## NOTES: Write cleaned file to disk. Select the file type (e.g., CSV, TSV,
## Stata, Rdata) and include additional arguments required by -haven- or base R
## writing functions.

write_dua_df(df = &#39;&lt; data frame &gt;&#39;, output_type = &#39;&lt; output file type &gt;&#39;

## -----------------------------------------------------------------------------
## end script
################################################################################
</code></pre>

</body>

</html>
